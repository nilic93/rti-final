{"ast":null,"code":"\"use strict\";\n\nvar Node = require('./Node');\n\nvar Element = require('./Element');\n\nvar CSSStyleDeclaration = require('./CSSStyleDeclaration');\n\nvar utils = require('./utils');\n\nvar URLUtils = require('./URLUtils');\n\nvar defineElement = require('./defineElement');\n\nvar htmlElements = exports.elements = {};\nvar htmlNameToImpl = Object.create(null);\n\nexports.createElement = function (doc, localName, prefix) {\n  var impl = htmlNameToImpl[localName] || HTMLUnknownElement;\n  return new impl(doc, localName, prefix);\n};\n\nfunction define(spec) {\n  return defineElement(spec, HTMLElement, htmlElements, htmlNameToImpl);\n}\n\nfunction URL(attr) {\n  return {\n    get: function () {\n      var v = this._getattr(attr);\n\n      if (v === null) {\n        return '';\n      }\n\n      var url = this.doc._resolve(v);\n\n      return url === null ? v : url;\n    },\n    set: function (value) {\n      this._setattr(attr, value);\n    }\n  };\n}\n\nfunction CORS(attr) {\n  return {\n    get: function () {\n      var v = this._getattr(attr);\n\n      if (v === null) {\n        return null;\n      }\n\n      if (v.toLowerCase() === 'use-credentials') {\n        return 'use-credentials';\n      }\n\n      return 'anonymous';\n    },\n    set: function (value) {\n      if (value === null || value === undefined) {\n        this.removeAttribute(attr);\n      } else {\n        this._setattr(attr, value);\n      }\n    }\n  };\n}\n\nvar REFERRER = {\n  type: [\"\", \"no-referrer\", \"no-referrer-when-downgrade\", \"same-origin\", \"origin\", \"strict-origin\", \"origin-when-cross-origin\", \"strict-origin-when-cross-origin\", \"unsafe-url\"],\n  missing: ''\n}; // XXX: the default value for tabIndex should be 0 if the element is\n// focusable and -1 if it is not.  But the full definition of focusable\n// is actually hard to compute, so for now, I'll follow Firefox and\n// just base the default value on the type of the element.\n\nvar focusableElements = {\n  \"A\": true,\n  \"LINK\": true,\n  \"BUTTON\": true,\n  \"INPUT\": true,\n  \"SELECT\": true,\n  \"TEXTAREA\": true,\n  \"COMMAND\": true\n};\n\nvar HTMLFormElement = function (doc, localName, prefix) {\n  HTMLElement.call(this, doc, localName, prefix);\n  this._form = null; // Prevent later deoptimization\n};\n\nvar HTMLElement = exports.HTMLElement = define({\n  superclass: Element,\n  ctor: function HTMLElement(doc, localName, prefix) {\n    Element.call(this, doc, localName, utils.NAMESPACE.HTML, prefix);\n  },\n  props: {\n    innerHTML: {\n      get: function () {\n        return this.serialize();\n      },\n      set: function (v) {\n        var parser = this.ownerDocument.implementation.mozHTMLParser(this.ownerDocument._address, this);\n        parser.parse(v === null ? '' : String(v), true); // Remove any existing children of this node\n\n        var target = this instanceof htmlNameToImpl.template ? this.content : this;\n\n        while (target.hasChildNodes()) target.removeChild(target.firstChild); // Now copy newly parsed children to this node\n\n\n        target.appendChild(parser._asDocumentFragment());\n      }\n    },\n    style: {\n      get: function () {\n        if (!this._style) this._style = new CSSStyleDeclaration(this);\n        return this._style;\n      },\n      set: function (v) {\n        if (v === null || v === undefined) {\n          v = '';\n        }\n\n        this._setattr('style', String(v));\n      }\n    },\n    // These can't really be implemented server-side in a reasonable way.\n    blur: {\n      value: function () {}\n    },\n    focus: {\n      value: function () {}\n    },\n    forceSpellCheck: {\n      value: function () {}\n    },\n    click: {\n      value: function () {\n        if (this._click_in_progress) return;\n        this._click_in_progress = true;\n\n        try {\n          if (this._pre_click_activation_steps) this._pre_click_activation_steps();\n          var event = this.ownerDocument.createEvent(\"MouseEvent\");\n          event.initMouseEvent(\"click\", true, true, this.ownerDocument.defaultView, 1, 0, 0, 0, 0, // These 4 should be initialized with\n          // the actually current keyboard state\n          // somehow...\n          false, false, false, false, 0, null); // Dispatch this as an untrusted event since it is synthetic\n\n          var success = this.dispatchEvent(event);\n\n          if (success) {\n            if (this._post_click_activation_steps) this._post_click_activation_steps(event);\n          } else {\n            if (this._cancelled_activation_steps) this._cancelled_activation_steps();\n          }\n        } finally {\n          this._click_in_progress = false;\n        }\n      }\n    },\n    submit: {\n      value: utils.nyi\n    }\n  },\n  attributes: {\n    title: String,\n    lang: String,\n    dir: {\n      type: [\"ltr\", \"rtl\", \"auto\"],\n      missing: ''\n    },\n    accessKey: String,\n    hidden: Boolean,\n    tabIndex: {\n      type: \"long\",\n      default: function () {\n        if (this.tagName in focusableElements || this.contentEditable) return 0;else return -1;\n      }\n    }\n  },\n  events: [\"abort\", \"canplay\", \"canplaythrough\", \"change\", \"click\", \"contextmenu\", \"cuechange\", \"dblclick\", \"drag\", \"dragend\", \"dragenter\", \"dragleave\", \"dragover\", \"dragstart\", \"drop\", \"durationchange\", \"emptied\", \"ended\", \"input\", \"invalid\", \"keydown\", \"keypress\", \"keyup\", \"loadeddata\", \"loadedmetadata\", \"loadstart\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"mousewheel\", \"pause\", \"play\", \"playing\", \"progress\", \"ratechange\", \"readystatechange\", \"reset\", \"seeked\", \"seeking\", \"select\", \"show\", \"stalled\", \"submit\", \"suspend\", \"timeupdate\", \"volumechange\", \"waiting\", // These last 5 event types will be overriden by HTMLBodyElement\n  \"blur\", \"error\", \"focus\", \"load\", \"scroll\"]\n}); // XXX: reflect contextmenu as contextMenu, with element type\n// style: the spec doesn't call this a reflected attribute.\n//   may want to handle it manually.\n// contentEditable: enumerated, not clear if it is actually\n// reflected or requires custom getter/setter. Not listed as\n// \"limited to known values\".  Raises syntax_err on bad setting,\n// so I think this is custom.\n// contextmenu: content is element id, idl type is an element\n// draggable: boolean, but not a reflected attribute\n// dropzone: reflected SettableTokenList, experimental, so don't\n//   implement it right away.\n// data-* attributes: need special handling in setAttribute?\n// Or maybe that isn't necessary. Can I just scan the attribute list\n// when building the dataset?  Liveness and caching issues?\n// microdata attributes: many are simple reflected attributes, but\n// I'm not going to implement this now.\n\nvar HTMLUnknownElement = define({\n  ctor: function HTMLUnknownElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  }\n});\nvar formAssociatedProps = {\n  // See http://www.w3.org/TR/html5/association-of-controls-and-forms.html#form-owner\n  form: {\n    get: function () {\n      return this._form;\n    }\n  }\n};\ndefine({\n  tag: 'a',\n  ctor: function HTMLAnchorElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    _post_click_activation_steps: {\n      value: function (e) {\n        if (this.href) {\n          // Follow the link\n          // XXX: this is just a quick hack\n          // XXX: the HTML spec probably requires more than this\n          this.ownerDocument.defaultView.location = this.href;\n        }\n      }\n    }\n  },\n  attributes: {\n    href: URL,\n    ping: String,\n    download: String,\n    target: String,\n    rel: String,\n    media: String,\n    hreflang: String,\n    type: String,\n    referrerPolicy: REFERRER,\n    // Obsolete\n    coords: String,\n    charset: String,\n    name: String,\n    rev: String,\n    shape: String\n  }\n}); // Latest WhatWG spec says these methods come via HTMLHyperlinkElementUtils\n\nURLUtils._inherit(htmlNameToImpl.a.prototype);\n\ndefine({\n  tag: 'area',\n  ctor: function HTMLAreaElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    alt: String,\n    target: String,\n    download: String,\n    rel: String,\n    media: String,\n    href: URL,\n    hreflang: String,\n    type: String,\n    shape: String,\n    coords: String,\n    ping: String,\n    // XXX: also reflect relList\n    referrerPolicy: REFERRER,\n    // Obsolete\n    noHref: Boolean\n  }\n}); // Latest WhatWG spec says these methods come via HTMLHyperlinkElementUtils\n\nURLUtils._inherit(htmlNameToImpl.area.prototype);\n\ndefine({\n  tag: 'br',\n  ctor: function HTMLBRElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    clear: String\n  }\n});\ndefine({\n  tag: 'base',\n  ctor: function HTMLBaseElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    \"target\": String\n  }\n});\ndefine({\n  tag: 'body',\n  ctor: function HTMLBodyElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  // Certain event handler attributes on a <body> tag actually set\n  // handlers for the window rather than just that element.  Define\n  // getters and setters for those here.  Note that some of these override\n  // properties on HTMLElement.prototype.\n  // XXX: If I add support for <frameset>, these have to go there, too\n  // XXX\n  // When the Window object is implemented, these attribute will have\n  // to work with the same-named attributes on the Window.\n  events: [\"afterprint\", \"beforeprint\", \"beforeunload\", \"blur\", \"error\", \"focus\", \"hashchange\", \"load\", \"message\", \"offline\", \"online\", \"pagehide\", \"pageshow\", \"popstate\", \"resize\", \"scroll\", \"storage\", \"unload\"],\n  attributes: {\n    // Obsolete\n    text: {\n      type: String,\n      treatNullAsEmptyString: true\n    },\n    link: {\n      type: String,\n      treatNullAsEmptyString: true\n    },\n    vLink: {\n      type: String,\n      treatNullAsEmptyString: true\n    },\n    aLink: {\n      type: String,\n      treatNullAsEmptyString: true\n    },\n    bgColor: {\n      type: String,\n      treatNullAsEmptyString: true\n    },\n    background: String\n  }\n});\ndefine({\n  tag: 'button',\n  ctor: function HTMLButtonElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: formAssociatedProps,\n  attributes: {\n    name: String,\n    value: String,\n    disabled: Boolean,\n    autofocus: Boolean,\n    type: {\n      type: [\"submit\", \"reset\", \"button\", \"menu\"],\n      missing: 'submit'\n    },\n    formTarget: String,\n    formNoValidate: Boolean,\n    formMethod: {\n      type: [\"get\", \"post\", \"dialog\"],\n      invalid: 'get',\n      missing: ''\n    },\n    formEnctype: {\n      type: [\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"],\n      invalid: \"application/x-www-form-urlencoded\",\n      missing: ''\n    }\n  }\n});\ndefine({\n  tag: 'dl',\n  ctor: function HTMLDListElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    compact: Boolean\n  }\n});\ndefine({\n  tag: 'data',\n  ctor: function HTMLDataElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    value: String\n  }\n});\ndefine({\n  tag: 'datalist',\n  ctor: function HTMLDataListElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  }\n});\ndefine({\n  tag: 'details',\n  ctor: function HTMLDetailsElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    \"open\": Boolean\n  }\n});\ndefine({\n  tag: 'div',\n  ctor: function HTMLDivElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    align: String\n  }\n});\ndefine({\n  tag: 'embed',\n  ctor: function HTMLEmbedElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    src: URL,\n    type: String,\n    width: String,\n    height: String,\n    // Obsolete\n    align: String,\n    name: String\n  }\n});\ndefine({\n  tag: 'fieldset',\n  ctor: function HTMLFieldSetElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: formAssociatedProps,\n  attributes: {\n    disabled: Boolean,\n    name: String\n  }\n});\ndefine({\n  tag: 'form',\n  ctor: function HTMLFormElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    action: String,\n    autocomplete: {\n      type: ['on', 'off'],\n      missing: 'on'\n    },\n    name: String,\n    acceptCharset: {\n      name: \"accept-charset\"\n    },\n    target: String,\n    noValidate: Boolean,\n    method: {\n      type: [\"get\", \"post\", \"dialog\"],\n      invalid: 'get',\n      missing: 'get'\n    },\n    // Both enctype and encoding reflect the enctype content attribute\n    enctype: {\n      type: [\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"],\n      invalid: \"application/x-www-form-urlencoded\",\n      missing: \"application/x-www-form-urlencoded\"\n    },\n    encoding: {\n      name: 'enctype',\n      type: [\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"],\n      invalid: \"application/x-www-form-urlencoded\",\n      missing: \"application/x-www-form-urlencoded\"\n    }\n  }\n});\ndefine({\n  tag: 'hr',\n  ctor: function HTMLHRElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    align: String,\n    color: String,\n    noShade: Boolean,\n    size: String,\n    width: String\n  }\n});\ndefine({\n  tag: 'head',\n  ctor: function HTMLHeadElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  }\n});\ndefine({\n  tags: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n  ctor: function HTMLHeadingElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    align: String\n  }\n});\ndefine({\n  tag: 'html',\n  ctor: function HTMLHtmlElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    version: String\n  }\n});\ndefine({\n  tag: 'iframe',\n  ctor: function HTMLIFrameElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n\n    var Window = require('./Window'); // Avoid circular dependencies.\n\n\n    this._contentWindow = new Window();\n  },\n  props: {\n    contentWindow: {\n      get: function () {\n        return this._contentWindow;\n      }\n    },\n    contentDocument: {\n      get: function () {\n        return this.contentWindow.document;\n      }\n    }\n  },\n  attributes: {\n    src: URL,\n    srcdoc: String,\n    name: String,\n    width: String,\n    height: String,\n    // XXX: sandbox is a reflected settable token list\n    seamless: Boolean,\n    allowFullscreen: Boolean,\n    allowUserMedia: Boolean,\n    allowPaymentRequest: Boolean,\n    referrerPolicy: REFERRER,\n    // Obsolete\n    align: String,\n    scrolling: String,\n    frameBorder: String,\n    longDesc: URL,\n    marginHeight: {\n      type: String,\n      treatNullAsEmptyString: true\n    },\n    marginWidth: {\n      type: String,\n      treatNullAsEmptyString: true\n    }\n  }\n});\ndefine({\n  tag: 'img',\n  ctor: function HTMLImageElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    alt: String,\n    src: URL,\n    srcset: String,\n    crossOrigin: CORS,\n    useMap: String,\n    isMap: Boolean,\n    height: {\n      type: \"unsigned long\",\n      default: 0\n    },\n    width: {\n      type: \"unsigned long\",\n      default: 0\n    },\n    referrerPolicy: REFERRER,\n    // Obsolete:\n    name: String,\n    lowsrc: URL,\n    align: String,\n    hspace: {\n      type: \"unsigned long\",\n      default: 0\n    },\n    vspace: {\n      type: \"unsigned long\",\n      default: 0\n    },\n    longDesc: URL,\n    border: {\n      type: String,\n      treatNullAsEmptyString: true\n    }\n  }\n});\ndefine({\n  tag: 'input',\n  ctor: function HTMLInputElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    form: formAssociatedProps.form,\n    _post_click_activation_steps: {\n      value: function (e) {\n        if (this.type === 'checkbox') {\n          this.checked = !this.checked;\n        } else if (this.type === 'radio') {\n          var group = this.form.getElementsByName(this.name);\n\n          for (var i = group.length - 1; i >= 0; i--) {\n            var el = group[i];\n            el.checked = el === this;\n          }\n        }\n      }\n    }\n  },\n  attributes: {\n    name: String,\n    disabled: Boolean,\n    autofocus: Boolean,\n    accept: String,\n    alt: String,\n    max: String,\n    min: String,\n    pattern: String,\n    placeholder: String,\n    step: String,\n    dirName: String,\n    defaultValue: {\n      name: 'value'\n    },\n    multiple: Boolean,\n    required: Boolean,\n    readOnly: Boolean,\n    checked: Boolean,\n    value: String,\n    src: URL,\n    defaultChecked: {\n      name: 'checked',\n      type: Boolean\n    },\n    size: {\n      type: 'unsigned long',\n      default: 20,\n      min: 1,\n      setmin: 1\n    },\n    width: {\n      type: 'unsigned long',\n      min: 0,\n      setmin: 0,\n      default: 0\n    },\n    height: {\n      type: 'unsigned long',\n      min: 0,\n      setmin: 0,\n      default: 0\n    },\n    minLength: {\n      type: 'unsigned long',\n      min: 0,\n      setmin: 0,\n      default: -1\n    },\n    maxLength: {\n      type: 'unsigned long',\n      min: 0,\n      setmin: 0,\n      default: -1\n    },\n    autocomplete: String,\n    // It's complicated\n    type: {\n      type: [\"text\", \"hidden\", \"search\", \"tel\", \"url\", \"email\", \"password\", \"datetime\", \"date\", \"month\", \"week\", \"time\", \"datetime-local\", \"number\", \"range\", \"color\", \"checkbox\", \"radio\", \"file\", \"submit\", \"image\", \"reset\", \"button\"],\n      missing: 'text'\n    },\n    formTarget: String,\n    formNoValidate: Boolean,\n    formMethod: {\n      type: [\"get\", \"post\"],\n      invalid: 'get',\n      missing: ''\n    },\n    formEnctype: {\n      type: [\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"],\n      invalid: \"application/x-www-form-urlencoded\",\n      missing: ''\n    },\n    inputMode: {\n      type: [\"verbatim\", \"latin\", \"latin-name\", \"latin-prose\", \"full-width-latin\", \"kana\", \"kana-name\", \"katakana\", \"numeric\", \"tel\", \"email\", \"url\"],\n      missing: ''\n    },\n    // Obsolete\n    align: String,\n    useMap: String\n  }\n});\ndefine({\n  tag: 'keygen',\n  ctor: function HTMLKeygenElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: formAssociatedProps,\n  attributes: {\n    name: String,\n    disabled: Boolean,\n    autofocus: Boolean,\n    challenge: String,\n    keytype: {\n      type: [\"rsa\"],\n      missing: ''\n    }\n  }\n});\ndefine({\n  tag: 'li',\n  ctor: function HTMLLIElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    value: {\n      type: \"long\",\n      default: 0\n    },\n    // Obsolete\n    type: String\n  }\n});\ndefine({\n  tag: 'label',\n  ctor: function HTMLLabelElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: formAssociatedProps,\n  attributes: {\n    htmlFor: {\n      name: 'for',\n      type: String\n    }\n  }\n});\ndefine({\n  tag: 'legend',\n  ctor: function HTMLLegendElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    align: String\n  }\n});\ndefine({\n  tag: 'link',\n  ctor: function HTMLLinkElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // XXX Reflect DOMSettableTokenList sizes also DOMTokenList relList\n    href: URL,\n    rel: String,\n    media: String,\n    hreflang: String,\n    type: String,\n    crossOrigin: CORS,\n    nonce: String,\n    integrity: String,\n    referrerPolicy: REFERRER,\n    // Obsolete\n    charset: String,\n    rev: String,\n    target: String\n  }\n});\ndefine({\n  tag: 'map',\n  ctor: function HTMLMapElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    name: String\n  }\n});\ndefine({\n  tag: 'menu',\n  ctor: function HTMLMenuElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // XXX: not quite right, default should be popup if parent element is\n    // popup.\n    type: {\n      type: ['context', 'popup', 'toolbar'],\n      missing: 'toolbar'\n    },\n    label: String,\n    // Obsolete\n    compact: Boolean\n  }\n});\ndefine({\n  tag: 'meta',\n  ctor: function HTMLMetaElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    name: String,\n    content: String,\n    httpEquiv: {\n      name: 'http-equiv',\n      type: String\n    },\n    // Obsolete\n    scheme: String\n  }\n});\ndefine({\n  tag: 'meter',\n  ctor: function HTMLMeterElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: formAssociatedProps\n});\ndefine({\n  tags: ['ins', 'del'],\n  ctor: function HTMLModElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    cite: URL,\n    dateTime: String\n  }\n});\ndefine({\n  tag: 'ol',\n  ctor: function HTMLOListElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    // Utility function (see the start attribute default value). Returns\n    // the number of <li> children of this element\n    _numitems: {\n      get: function () {\n        var items = 0;\n        this.childNodes.forEach(function (n) {\n          if (n.nodeType === Node.ELEMENT_NODE && n.tagName === \"LI\") items++;\n        });\n        return items;\n      }\n    }\n  },\n  attributes: {\n    type: String,\n    reversed: Boolean,\n    start: {\n      type: \"long\",\n      default: function () {\n        // The default value of the start attribute is 1 unless the list is\n        // reversed. Then it is the # of li children\n        if (this.reversed) return this._numitems;else return 1;\n      }\n    },\n    // Obsolete\n    compact: Boolean\n  }\n});\ndefine({\n  tag: 'object',\n  ctor: function HTMLObjectElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: formAssociatedProps,\n  attributes: {\n    data: URL,\n    type: String,\n    name: String,\n    useMap: String,\n    typeMustMatch: Boolean,\n    width: String,\n    height: String,\n    // Obsolete\n    align: String,\n    archive: String,\n    code: String,\n    declare: Boolean,\n    hspace: {\n      type: \"unsigned long\",\n      default: 0\n    },\n    standby: String,\n    vspace: {\n      type: \"unsigned long\",\n      default: 0\n    },\n    codeBase: URL,\n    codeType: String,\n    border: {\n      type: String,\n      treatNullAsEmptyString: true\n    }\n  }\n});\ndefine({\n  tag: 'optgroup',\n  ctor: function HTMLOptGroupElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    disabled: Boolean,\n    label: String\n  }\n});\ndefine({\n  tag: 'option',\n  ctor: function HTMLOptionElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    form: {\n      get: function () {\n        var p = this.parentNode;\n\n        while (p && p.nodeType === Node.ELEMENT_NODE) {\n          if (p.localName === 'select') return p.form;\n          p = p.parentNode;\n        }\n      }\n    },\n    value: {\n      get: function () {\n        return this._getattr('value') || this.text;\n      },\n      set: function (v) {\n        this._setattr('value', v);\n      }\n    },\n    text: {\n      get: function () {\n        // Strip and collapse whitespace\n        return this.textContent.replace(/[ \\t\\n\\f\\r]+/g, ' ').trim();\n      },\n      set: function (v) {\n        this.textContent = v;\n      }\n    } // missing: index\n\n  },\n  attributes: {\n    disabled: Boolean,\n    defaultSelected: {\n      name: 'selected',\n      type: Boolean\n    },\n    label: String\n  }\n});\ndefine({\n  tag: 'output',\n  ctor: function HTMLOutputElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: formAssociatedProps,\n  attributes: {\n    // XXX Reflect for/htmlFor as a settable token list\n    name: String\n  }\n});\ndefine({\n  tag: 'p',\n  ctor: function HTMLParagraphElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    align: String\n  }\n});\ndefine({\n  tag: 'param',\n  ctor: function HTMLParamElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    name: String,\n    value: String,\n    // Obsolete\n    type: String,\n    valueType: String\n  }\n});\ndefine({\n  tags: ['pre',\n  /*legacy elements:*/\n  'listing', 'xmp'],\n  ctor: function HTMLPreElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    width: {\n      type: \"long\",\n      default: 0\n    }\n  }\n});\ndefine({\n  tag: 'progress',\n  ctor: function HTMLProgressElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: formAssociatedProps,\n  attributes: {\n    max: {\n      type: Number,\n      float: true,\n      default: 1.0,\n      min: 0\n    }\n  }\n});\ndefine({\n  tags: ['q', 'blockquote'],\n  ctor: function HTMLQuoteElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    cite: URL\n  }\n});\ndefine({\n  tag: 'script',\n  ctor: function HTMLScriptElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    text: {\n      get: function () {\n        var s = \"\";\n\n        for (var i = 0, n = this.childNodes.length; i < n; i++) {\n          var child = this.childNodes[i];\n          if (child.nodeType === Node.TEXT_NODE) s += child._data;\n        }\n\n        return s;\n      },\n      set: function (value) {\n        this.removeChildren();\n\n        if (value !== null && value !== \"\") {\n          this.appendChild(this.ownerDocument.createTextNode(value));\n        }\n      }\n    }\n  },\n  attributes: {\n    src: URL,\n    type: String,\n    charset: String,\n    defer: Boolean,\n    async: Boolean,\n    crossOrigin: CORS,\n    nonce: String,\n    integrity: String\n  }\n});\ndefine({\n  tag: 'select',\n  ctor: function HTMLSelectElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    form: formAssociatedProps.form,\n    options: {\n      get: function () {\n        return this.getElementsByTagName('option');\n      }\n    }\n  },\n  attributes: {\n    autocomplete: String,\n    // It's complicated\n    name: String,\n    disabled: Boolean,\n    autofocus: Boolean,\n    multiple: Boolean,\n    required: Boolean,\n    size: {\n      type: \"unsigned long\",\n      default: 0\n    }\n  }\n});\ndefine({\n  tag: 'source',\n  ctor: function HTMLSourceElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    src: URL,\n    type: String,\n    media: String\n  }\n});\ndefine({\n  tag: 'span',\n  ctor: function HTMLSpanElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  }\n});\ndefine({\n  tag: 'style',\n  ctor: function HTMLStyleElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    media: String,\n    type: String,\n    scoped: Boolean\n  }\n});\ndefine({\n  tag: 'caption',\n  ctor: function HTMLTableCaptionElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    align: String\n  }\n});\ndefine({\n  ctor: function HTMLTableCellElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    colSpan: {\n      type: \"unsigned long\",\n      default: 1\n    },\n    rowSpan: {\n      type: \"unsigned long\",\n      default: 1\n    },\n    //XXX Also reflect settable token list headers\n    scope: {\n      type: ['row', 'col', 'rowgroup', 'colgroup'],\n      missing: ''\n    },\n    abbr: String,\n    // Obsolete\n    align: String,\n    axis: String,\n    height: String,\n    width: String,\n    ch: {\n      name: 'char',\n      type: String\n    },\n    chOff: {\n      name: 'charoff',\n      type: String\n    },\n    noWrap: Boolean,\n    vAlign: String,\n    bgColor: {\n      type: String,\n      treatNullAsEmptyString: true\n    }\n  }\n});\ndefine({\n  tags: ['col', 'colgroup'],\n  ctor: function HTMLTableColElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    span: {\n      type: 'limited unsigned long with fallback',\n      default: 1,\n      min: 1\n    },\n    // Obsolete\n    align: String,\n    ch: {\n      name: 'char',\n      type: String\n    },\n    chOff: {\n      name: 'charoff',\n      type: String\n    },\n    vAlign: String,\n    width: String\n  }\n});\ndefine({\n  tag: 'table',\n  ctor: function HTMLTableElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    rows: {\n      get: function () {\n        return this.getElementsByTagName('tr');\n      }\n    }\n  },\n  attributes: {\n    // Obsolete\n    align: String,\n    border: String,\n    frame: String,\n    rules: String,\n    summary: String,\n    width: String,\n    bgColor: {\n      type: String,\n      treatNullAsEmptyString: true\n    },\n    cellPadding: {\n      type: String,\n      treatNullAsEmptyString: true\n    },\n    cellSpacing: {\n      type: String,\n      treatNullAsEmptyString: true\n    }\n  }\n});\ndefine({\n  tag: 'template',\n  ctor: function HTMLTemplateElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n    this._contentFragment = doc._templateDoc.createDocumentFragment();\n  },\n  props: {\n    content: {\n      get: function () {\n        return this._contentFragment;\n      }\n    },\n    serialize: {\n      value: function () {\n        return this.content.serialize();\n      }\n    }\n  }\n});\ndefine({\n  tag: 'tr',\n  ctor: function HTMLTableRowElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    cells: {\n      get: function () {\n        return this.querySelectorAll('td,th');\n      }\n    }\n  },\n  attributes: {\n    // Obsolete\n    align: String,\n    ch: {\n      name: 'char',\n      type: String\n    },\n    chOff: {\n      name: 'charoff',\n      type: String\n    },\n    vAlign: String,\n    bgColor: {\n      type: String,\n      treatNullAsEmptyString: true\n    }\n  }\n});\ndefine({\n  tags: ['thead', 'tfoot', 'tbody'],\n  ctor: function HTMLTableSectionElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    rows: {\n      get: function () {\n        return this.getElementsByTagName('tr');\n      }\n    }\n  },\n  attributes: {\n    // Obsolete\n    align: String,\n    ch: {\n      name: 'char',\n      type: String\n    },\n    chOff: {\n      name: 'charoff',\n      type: String\n    },\n    vAlign: String\n  }\n});\ndefine({\n  tag: 'textarea',\n  ctor: function HTMLTextAreaElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    form: formAssociatedProps.form,\n    type: {\n      get: function () {\n        return 'textarea';\n      }\n    },\n    defaultValue: {\n      get: function () {\n        return this.textContent;\n      },\n      set: function (v) {\n        this.textContent = v;\n      }\n    },\n    value: {\n      get: function () {\n        return this.defaultValue;\n        /* never dirty */\n      },\n      set: function (v) {\n        // This isn't completely correct: according to the spec, this\n        // should \"dirty\" the API value, and result in\n        // `this.value !== this.defaultValue`.  But for most of what\n        // folks want to do, this implementation should be fine:\n        this.defaultValue = v;\n      }\n    },\n    textLength: {\n      get: function () {\n        return this.value.length;\n      }\n    }\n  },\n  attributes: {\n    autocomplete: String,\n    // It's complicated\n    name: String,\n    disabled: Boolean,\n    autofocus: Boolean,\n    placeholder: String,\n    wrap: String,\n    dirName: String,\n    required: Boolean,\n    readOnly: Boolean,\n    rows: {\n      type: 'limited unsigned long with fallback',\n      default: 2\n    },\n    cols: {\n      type: 'limited unsigned long with fallback',\n      default: 20\n    },\n    maxLength: {\n      type: 'unsigned long',\n      min: 0,\n      setmin: 0,\n      default: -1\n    },\n    minLength: {\n      type: 'unsigned long',\n      min: 0,\n      setmin: 0,\n      default: -1\n    },\n    inputMode: {\n      type: [\"verbatim\", \"latin\", \"latin-name\", \"latin-prose\", \"full-width-latin\", \"kana\", \"kana-name\", \"katakana\", \"numeric\", \"tel\", \"email\", \"url\"],\n      missing: ''\n    }\n  }\n});\ndefine({\n  tag: 'time',\n  ctor: function HTMLTimeElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    dateTime: String,\n    pubDate: Boolean\n  }\n});\ndefine({\n  tag: 'title',\n  ctor: function HTMLTitleElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    text: {\n      get: function () {\n        return this.textContent;\n      }\n    }\n  }\n});\ndefine({\n  tag: 'ul',\n  ctor: function HTMLUListElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    type: String,\n    // Obsolete\n    compact: Boolean\n  }\n});\ndefine({\n  ctor: function HTMLMediaElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    src: URL,\n    crossOrigin: CORS,\n    preload: {\n      type: [\"metadata\", \"none\", \"auto\", {\n        value: \"\",\n        alias: \"auto\"\n      }],\n      missing: 'auto'\n    },\n    loop: Boolean,\n    autoplay: Boolean,\n    mediaGroup: String,\n    controls: Boolean,\n    defaultMuted: {\n      name: \"muted\",\n      type: Boolean\n    }\n  }\n});\ndefine({\n  tag: 'audio',\n  superclass: htmlElements.HTMLMediaElement,\n  ctor: function HTMLAudioElement(doc, localName, prefix) {\n    htmlElements.HTMLMediaElement.call(this, doc, localName, prefix);\n  }\n});\ndefine({\n  tag: 'video',\n  superclass: htmlElements.HTMLMediaElement,\n  ctor: function HTMLVideoElement(doc, localName, prefix) {\n    htmlElements.HTMLMediaElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    poster: URL,\n    width: {\n      type: \"unsigned long\",\n      min: 0,\n      default: 0\n    },\n    height: {\n      type: \"unsigned long\",\n      min: 0,\n      default: 0\n    }\n  }\n});\ndefine({\n  tag: 'td',\n  superclass: htmlElements.HTMLTableCellElement,\n  ctor: function HTMLTableDataCellElement(doc, localName, prefix) {\n    htmlElements.HTMLTableCellElement.call(this, doc, localName, prefix);\n  }\n});\ndefine({\n  tag: 'th',\n  superclass: htmlElements.HTMLTableCellElement,\n  ctor: function HTMLTableHeaderCellElement(doc, localName, prefix) {\n    htmlElements.HTMLTableCellElement.call(this, doc, localName, prefix);\n  }\n});\ndefine({\n  tag: 'frameset',\n  ctor: function HTMLFrameSetElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  }\n});\ndefine({\n  tag: 'frame',\n  ctor: function HTMLFrameElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  }\n});\ndefine({\n  tag: 'canvas',\n  ctor: function HTMLCanvasElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    getContext: {\n      value: utils.nyi\n    },\n    probablySupportsContext: {\n      value: utils.nyi\n    },\n    setContext: {\n      value: utils.nyi\n    },\n    transferControlToProxy: {\n      value: utils.nyi\n    },\n    toDataURL: {\n      value: utils.nyi\n    },\n    toBlob: {\n      value: utils.nyi\n    }\n  },\n  attributes: {\n    width: {\n      type: \"unsigned long\",\n      default: 300\n    },\n    height: {\n      type: \"unsigned long\",\n      default: 150\n    }\n  }\n});\ndefine({\n  tag: 'dialog',\n  ctor: function HTMLDialogElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    show: {\n      value: utils.nyi\n    },\n    showModal: {\n      value: utils.nyi\n    },\n    close: {\n      value: utils.nyi\n    }\n  },\n  attributes: {\n    open: Boolean,\n    returnValue: String\n  }\n});\ndefine({\n  tag: 'menuitem',\n  ctor: function HTMLMenuItemElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    // The menuitem's label\n    _label: {\n      get: function () {\n        var val = this._getattr('label');\n\n        if (val !== null && val !== '') {\n          return val;\n        }\n\n        val = this.textContent; // Strip and collapse whitespace\n\n        return val.replace(/[ \\t\\n\\f\\r]+/g, ' ').trim();\n      }\n    },\n    // The menuitem label IDL attribute\n    label: {\n      get: function () {\n        var val = this._getattr('label');\n\n        if (val !== null) {\n          return val;\n        }\n\n        return this._label;\n      },\n      set: function (v) {\n        this._setattr('label', v);\n      }\n    }\n  },\n  attributes: {\n    type: {\n      type: [\"command\", \"checkbox\", \"radio\"],\n      missing: 'command'\n    },\n    icon: URL,\n    disabled: Boolean,\n    checked: Boolean,\n    radiogroup: String,\n    default: Boolean\n  }\n});\ndefine({\n  tag: 'source',\n  ctor: function HTMLSourceElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    srcset: String,\n    sizes: String,\n    media: String,\n    src: URL,\n    type: String\n  }\n});\ndefine({\n  tag: 'track',\n  ctor: function HTMLTrackElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    src: URL,\n    srclang: String,\n    label: String,\n    default: Boolean,\n    kind: {\n      type: [\"subtitles\", \"captions\", \"descriptions\", \"chapters\", \"metadata\"],\n      missing: 'subtitles',\n      invalid: 'metadata'\n    }\n  },\n  props: {\n    NONE: {\n      get: function () {\n        return 0;\n      }\n    },\n    LOADING: {\n      get: function () {\n        return 1;\n      }\n    },\n    LOADED: {\n      get: function () {\n        return 2;\n      }\n    },\n    ERROR: {\n      get: function () {\n        return 3;\n      }\n    },\n    readyState: {\n      get: utils.nyi\n    },\n    track: {\n      get: utils.nyi\n    }\n  }\n});\ndefine({\n  // obsolete\n  tag: 'font',\n  ctor: function HTMLFontElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    color: {\n      type: String,\n      treatNullAsEmptyString: true\n    },\n    face: {\n      type: String\n    },\n    size: {\n      type: String\n    }\n  }\n});\ndefine({\n  // obsolete\n  tag: 'dir',\n  ctor: function HTMLDirectoryElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    compact: Boolean\n  }\n});\ndefine({\n  tags: [\"abbr\", \"address\", \"article\", \"aside\", \"b\", \"bdi\", \"bdo\", \"cite\", \"code\", \"dd\", \"dfn\", \"dt\", \"em\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"i\", \"kbd\", \"main\", \"mark\", \"nav\", \"noscript\", \"rb\", \"rp\", \"rt\", \"rtc\", \"ruby\", \"s\", \"samp\", \"section\", \"small\", \"strong\", \"sub\", \"summary\", \"sup\", \"u\", \"var\", \"wbr\", // Legacy elements\n  \"acronym\", \"basefont\", \"big\", \"center\", \"nobr\", \"noembed\", \"noframes\", \"plaintext\", \"strike\", \"tt\"]\n});","map":null,"metadata":{},"sourceType":"script"}